Author: Peter Mann <peter.mann@sh.cz>
Description: Memory leak in mdadm --monitor --scan (Closes: #1115497).
 At mdadm/udev.c:153:
 ...
 if (udev_monitor_receive_device(udev_monitor))
   return UDEV_STATUS_SUCCESS; /* event detected */
 ...
 .
 According to libudev docs:
 On success, udev_monitor_receive_device() returns a pointer to a newly referenced device that was received via the monitor. The caller is responsible to drop this reference when done.
 .
 As you can see, the reference to the device never gets dropped.
 We put together a quick patch, which seems to have fixed the issue or at least substantially reduced the amount of leaks.
 .
 Since we have no experience with the codebase, we have no idea about the implications of these changes.
 We would appreciate if someone took a closer look.
 .
 Additionaly as a workaround, passing MDADM_NO_UDEV=1 env to mdadm stops the leaks as well, since it bypasses the leaking codepath.

diff -Naurp mdadm.orig/udev.c mdadm/udev.c
--- mdadm.orig/udev.c
+++ mdadm/udev.c
@@ -149,9 +149,13 @@ enum udev_status udev_wait_for_events(in
 	tv.tv_sec = seconds;
 	tv.tv_usec = 0;
 
-	if (select(fd + 1, &readfds, NULL, NULL, &tv) > 0 && FD_ISSET(fd, &readfds))
-		if (udev_monitor_receive_device(udev_monitor))
+	if (select(fd + 1, &readfds, NULL, NULL, &tv) > 0 && FD_ISSET(fd, &readfds)) {
+		struct udev_device *dev = udev_monitor_receive_device(udev_monitor);
+		if (dev) {
+			udev_device_unref(dev);
 			return UDEV_STATUS_SUCCESS; /* event detected */
+		}
+	}
 	return UDEV_STATUS_TIMEOUT;
 }
 #endif
